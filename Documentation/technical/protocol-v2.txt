 Git Wire Protocol, Version 2
==============================

This document presents a specification for a version 2 of Git's wire
protocol.  Protocol v2 will improve upon v1 in the following ways:

  * Instead of multiple service names, multiple commands will be
    supported by a single service.
  * Easily extendable as capabilities are moved into their own section
    of the protocol, no longer being hidden behind a NUL byte and
    limited by the size of a pkt-line (as there will be a single
    capability per pkt-line).
  * Separate out other information hidden behind NUL bytes (e.g. agent
    string as a capability and symrefs can be requested using 'ls-refs')
  * Reference advertisement will be omitted unless explicitly requested
  * ls-refs command to explicitly request some refs

 Detailed Design
=================

A client can request to speak protocol v2 by sending `version=2` in the
side-channel `GIT_PROTOCOL` in the initial request to the server.

In protocol v2 communication is command oriented.  When first contacting a
server a list of capabilities will advertised.  Some of these capabilities
will be commands which a client can request be executed.  Once a command
has completed, a client can reuse the connection and request that other
commands be executed.

 Special Packets
-----------------

In protocol v2 these special packets will have the following semantics:

  * '0000' Flush Packet (flush-pkt) - indicates the end of a message
  * '0001' Delimiter Packet (delim-pkt) - separates sections of a message

 Capability Advertisement
--------------------------

A server which decides to communicate (based on a request from a client)
using protocol version 2, notifies the client by sending a version string
in its initial response followed by an advertisement of its capabilities.
Each capability is a key with an optional value.  Clients must ignore all
unknown keys.  Semantics of unknown values are left to the definition of
each key.  Some capabilities will describe commands which can be requested
to be executed by the client.

    capability-advertisement = protocol-version
			       capability-list
			       flush-pkt

    protocol-version = PKT-LINE("version 2" LF)
    capability-list = *capability
    capability = PKT-LINE(key[=value] LF)

    key = 1*CHAR
    value = 1*CHAR
    CHAR = 1*(ALPHA / DIGIT / "-" / "_")

A client then responds to select the command it wants with any particular
capabilities or arguments.  There is then an optional section where the
client can provide any command specific parameters or queries.

    command-request = command
		      capability-list
		      (command-args)
		      flush-pkt
    command = PKT-LINE("command=" key LF)
    command-args = delim-pkt
		   *arg
    arg = 1*CHAR

The server will then check to ensure that the client's request is
comprised of a valid command as well as valid capabilities which were
advertised.  If the request is valid the server will then execute the
command.

When a command has finished a client can either request that another
command be executed or can terminate the connection by sending an empty
request consisting of just a flush-pkt.

 Capabilities
~~~~~~~~~~~~~~

There are two different types of capabilities: normal capabilities,
which can be used to to convey information or alter the behavior of a
request, and command capabilities, which are the core actions that a
client wants to perform (fetch, push, etc).

 agent
-------

The server can advertise the `agent` capability with a value `X` (in the
form `agent=X`) to notify the client that the server is running version
`X`.  The client may optionally send its own agent string by including
the `agent` capability with a value `Y` (in the form `agent=Y`) in its
request to the server (but it MUST NOT do so if the server did not
advertise the agent capability). The `X` and `Y` strings may contain any
printable ASCII characters except space (i.e., the byte range 32 < x <
127), and are typically of the form "package/version" (e.g.,
"git/1.8.3.1"). The agent strings are purely informative for statistics
and debugging purposes, and MUST NOT be used to programmatically assume
the presence or absence of particular features.

 stateless-rpc
---------------

If advertised, the `stateless-rpc` capability indicates that the server
supports running commands in a stateless-rpc mode, which means that a
command lasts for only a single request-response round.

Normally a command can last for as many rounds as are required to
complete it (multiple for negotiation during fetch or no additional
trips in the case of ls-refs).  If the client sends the `stateless-rpc`
capability with a value of `true` (in the form `stateless-rpc=true`)
then the invoked command must only last a single round.
